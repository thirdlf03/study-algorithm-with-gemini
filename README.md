# A
```
問題: 配列の最大差

問題文:
整数の配列（リスト） arr が与えられます。配列内の要素の最大値と最小値の差を計算して出力してください。ただし、配列は少なくとも1つ以上の要素を含むものとします。

入力形式:
標準入力から、スペース区切りの整数のリストとして与えられます。

出力形式:
計算結果（最大値と最小値の差）を整数で出力してください。

制約:

配列 arr の要素数は 1 以上 1,000 以下です。
配列 arr の各要素の値は -1,000,000 以上 1,000,000 以下です。
入力例1:

3 1 4 1 5 9 2 6
出力例1:

8
(解説: 最大値は 9、最小値は 1 なので、差は 9 - 1 = 8)

入力例2:

10 10 10
出力例2:

0
(解説: 最大値も最小値も 10 なので、差は 10 - 10 = 0)

入力例3:

-3 -1 -4 -1 -5
出力例3:

4
(解説: 最大値は -1、最小値は -5 なので、差は -1 - (-5) = 4)
```

# B
```
問題: 条件を満たすペアの数

問題文:
整数のリスト nums と整数 k が与えられます。リスト nums から異なる2つの要素を選び、その和が k となるペアの数を数えてください。

例えば、nums = [1, 5, 3, 3, 2] で k = 6 の場合、和が6となるペアは (1, 5) と (3, 3) の2つです。（リスト内の同じ位置にある要素を2回使うことはできませんが、同じ値を持つ異なる位置の要素はペアとしてカウントできます。例えば、上記の例では nums[2] の 3 と nums[3] の 3 でペアを作れます）。

入力形式:
1行目に整数のリスト nums を表すスペース区切りの整数が与えられます。
2行目に整数 k が与えられます。

出力形式:
和が k となる異なるペアの数を整数で出力してください。

制約:

nums の要素数は 2 以上 1,000 以下です。
nums の各要素の値は -1,000 以上 1,000 以下です。
k の値は -2,000 以上 2,000 以下です。
入力例1:

1 5 3 3 2
6
出力例1:

2
(解説: (1, 5) と (3, 3) のペア。nums[2]とnums[3]の3を使っています)

入力例2:

1 2 3 4 5
5
出力例2:

2
(解説: (1, 4) と (2, 3) のペア)

入力例3:

1 1 1 1
2
出力例3:

6
(解説: 4つの1から2つを選ぶ組み合わせは6通りあり、すべて和が2になります)

入力例4:

10 20 30
100
出力例4:

0
```

# C
```
問題: 重複しない要素の和

問題文:
整数のリスト nums が与えられます。リスト nums に含まれる要素のうち、重複を除いたユニークな（一意な）要素だけをすべて合計した値を計算して出力してください。

入力形式:
標準入力から、スペース区切りの整数のリストとして与えられます。

出力形式:
ユニークな要素の合計値を整数で出力してください。

制約:

nums の要素数は 1 以上 1,000 以下です。
nums の各要素の値は -1,000 以上 1,000 以下です。
入力例1:

1 2 3 2 1 5
出力例1:

11
(解説: ユニークな要素は 1, 2, 3, 5。合計は 1 + 2 + 3 + 5 = 11)

入力例2:

10 10 10 10
出力例2:

10
(解説: ユニークな要素は 10 のみ。合計は 10)

入力例3:

-1 -2 -1 -3 -2
出力例3:

-6
(解説: ユニークな要素は -1, -2, -3。合計は -1 + (-2) + (-3) = -6)
```

# D
```
問題: 括弧の整合性チェック

問題文:
文字列 s が与えられます。この文字列には、'(', ')', '{', '}', '[', ']' の6種類の文字のみが含まれています。 与えられた文字列s` が、以下の条件を満たす「有効な括弧の並び」であるかどうかを判定してください。

開く括弧（ '(', '{', '[' ）は、同じ種類の閉じる括弧（ ')', '}', ']' ）によって閉じられている必要があります。
開く括弧は、正しい順序で閉じられている必要があります。（例: "([)]" は無効ですが、"{[]}" は有効です。）
空の文字列も有効な括弧の並びとみなします。
入力形式:
1行の文字列 s が標準入力から与えられます。

出力形式:
文字列 s が有効な括弧の並びであれば True を、そうでなければ False を出力してください。

制約:

s の長さは 0 以上 10,000 以下です。
s は '()[]{}' の6種類の文字のみで構成されます。
入力例1:

()[]{}
出力例1:

True
入力例2:

([)]
出力例2:

False
(解説: [ が ) で閉じられようとしているため無効)

入力例3:

{[]}
出力例3:

True
入力例4:

(]
出力例4:

False
(解説: ( が ] で閉じられようとしているため無効)

入力例5:

((
出力例5:

False
(解説: 開きっぱなしの括弧があるため無効)

入力例6:

}
出力例6:

False
(解説: 対応する開き括弧がない閉じ括弧があるため無効)

入力例7:

(空白文字列)
出力例7:

True
(解説: 空文字列は有効)
```

# E
```
問題: 配列の分割

問題文:
正の整数の配列（リスト） nums と、整数 m が与えられます。
あなたは、この配列 nums を 連続する部分配列 m 個に分割する必要があります（元の配列の順序は変えません）。
分割された各部分配列の要素の合計値を計算し、その中で最も大きい合計値（以下、これを「最大和」と呼びます）を考えます。
あなたの目標は、配列を m 個に分割する方法の中で、この**「最大和」が最も小さくなる**ように分割することです。その最小となる「最大和」の値を求めてください。

例えば、nums = [7, 2, 5, 10, 8] で m = 2 の場合、以下のように分割できます。

[7] と [2, 5, 10, 8] (合計: 7, 25) -> 最大和: 25
[7, 2] と [5, 10, 8] (合計: 9, 23) -> 最大和: 23
[7, 2, 5] と [10, 8] (合計: 14, 18) -> 最大和: 18
[7, 2, 5, 10] と [8] (合計: 24, 8) -> 最大和: 24
これらの分割方法の中で、最大和が最も小さいのは 18 です。

入力形式:
1行目に、スペース区切りの整数のリストとして nums が与えられます。
2行目に、整数 m （分割する数）が与えられます。

出力形式:
最小となる「最大和」の値を整数で出力してください。

制約:

nums の要素数は n で、1 <= n <= 1000 です。
nums の各要素の値は 0 <= nums[i] <= 1,000,000 です。（※0も含む点に注意）
1 <= m <= min(50, n) です。
入力例1:

7 2 5 10 8
2
出力例1:

18
入力例2:

1 2 3 4 5
2
出力例2:

9
(解説: [1, 2, 3] (合計6), [4, 5] (合計9) -> 最大和 9)

入力例3:

1 4 4
3
出力例3:

4
(解説: [1], [4], [4] と分割するのが最適。最大和は4)
```

# F
```
問題: 最頻出要素

問題文:
整数のリスト nums が与えられます。リストの中で最も出現回数が多い要素を一つ見つけてください。もし最も出現回数が多い要素が複数存在する場合は、そのうちのどれか一つを答えれば構いません。

入力形式:
1行目に、スペース区切りの整数のリストとして nums が与えられます。

出力形式:
最も出現回数が多い要素（整数）を一つ出力してください。

制約:

nums の要素数は 1 以上 100,000 以下です。
nums の各要素の値は -1,000,000,000 以上 1,000,000,000 以下です。
答えは必ず存在します（リストは空ではありません）。
入力例1:

1 2 3 2 2 1 4
出力例1:

2
(解説: 2が3回出現し、最も多い)

入力例2:

1 1 1 2 2 3
出力例2:

1
(解説: 1が3回で最も多い)

入力例3:

1 2 3 4 5
出力例3:

1
(解説: 全て1回ずつ出現。この場合、1, 2, 3, 4, 5 のどれを答えても正解。例えば1を出力)

入力例4:

-1 0 -1 0 0
出力例4:

0
(解説: 0が3回、-1が2回。0が最も多い)
```

# G
```
問題: ユニークな経路

問題文:
m x n のグリッド（格子）があります。あなたは左上のマス (0, 0) からスタートし、右下のマス (m-1, n-1) を目指します。
移動は、下に1マス または 右に1マス のどちらかの方向にしかできません。
スタート地点からゴール地点まで到達する、異なる経路の総数は何通りありますか？

入力形式:
1行目に整数 m (グリッドの行数)、2行目に整数 n (グリッドの列数) が標準入力から与えられます。

出力形式:
異なる経路の総数を整数で出力してください。

制約:

1 <= m, n <= 100
答えは 2∗10 
9
  を超えないことが保証されています。
入力例1:

3
7
出力例1:

28
(解説: 3x7グリッドの左上から右下への経路)

入力例2:

3
2
出力例2:

3
(解説: 3x2グリッド。経路は (右, 下, 下), (下, 右, 下), (下, 下, 右) の3通り)

入力例3:

7
3
出力例3:

28
入力例4:

1
1
出力例4:

1
(解説: スタートがゴールと同じ。移動なしの1通り)
```

# h
```
問題: ナップサック問題 (品物1個ずつ)

問題文:
あなたは容量が W のナップサックを持っています。また、n 個の品物があり、それぞれの品物 i (0-indexed) は重さ weights[i] と価値 values[i] を持っています。
あなたは、これらの品物の中からいくつかを選び、ナップサックに入れることができます。ただし、各品物は1個しかなく、それぞれについてナップサックに入れるか入れないかのどちらかしか選べません（同じ品物を2個以上入れることはできません）。

ナップサックに入れる品物の重さの合計が W を超えないようにしながら、ナップサックに入れる品物の価値の合計を最大化したいです。価値の合計の最大値はいくつですか？

入力形式:
1行目に整数 n (品物の数) と整数 W (ナップサックの容量) がスペース区切りで与えられます。
続く n 行に、各品物 i の重さ weights[i] と価値 values[i] がスペース区切りで与えられます。

出力形式:
価値の合計の最大値を整数で出力してください。

制約:

1 <= n <= 100
1 <= W <= 10000
1 <= weights[i] <= W
1 <= values[i] <= 1000
入力例1:

3 50
10 60
20 100
30 120
(品物0: 重さ10, 価値60 | 品物1: 重さ20, 価値100 | 品物2: 重さ30, 価値120)

出力例1:

220
(解説: 品物1(20, 100) と 品物2(30, 120) を入れるのが最適。重さ合計50、価値合計220)

入力例2:

4 5
1 8
2 4
3 0
2 5
(品物0: 重さ1, 価値8 | 品物1: 重さ2, 価値4 | 品物2: 重さ3, 価値0 | 品物3: 重さ2, 価値5)

出力例2:

13
(解説: 品物0(1, 8) と 品物3(2, 5) を入れるのが最適。重さ合計3、価値合計13。もし品物1(2,4)も入れようとすると重さ5になり価値は17だが、品物3の方が価値が高いので(1,8)と(2,5)の組み合わせが良い。) ※入力例2の解説を修正しました。正しい組み合わせは(1,8)と(2,5)で重さ3、価値13。

入力例3:

6 15
6 5
5 6
6 4
6 6
3 5
7 2
出力例3:

17
(解説: 品物1(5,6), 品物4(3,5), 品物0(6,5) を入れると重さ14、価値16。品物1(5,6), 品物4(3,5), 品物3(6,6) を入れると重さ14、価値17。これが最適か？)


```

# i
```
問題: 最長増加部分列 (Longest Increasing Subsequence - LIS)

問題文:
整数の配列（リスト） nums が与えられます。この配列の要素をいくつか（0個以上）取り出して、元の順序を保ったまま並べたものを部分列 (subsequence) といいます。
この部分列の中で、要素が単調に増加する（つまり、狭義増加： a[i] < a[i+1] ）もののうち、最も長さが長いものの長さを求めてください。

例えば、nums = [10, 9, 2, 5, 3, 7, 101, 18] の場合、

[2, 3, 7, 101] は増加部分列で、長さは 4 です。
[2, 5, 7, 101] も増加部分列で、長さは 4 です。
[10, 101] も増加部分列で、長さは 2 です。
[9, 2, 5] は部分列ですが、増加していないので増加部分列ではありません。
[2, 7, 3] は部分列ではありません（元の順序が保たれていない）。 この例での最長増加部分列の長さは 4 です。
入力形式:
1行目に、スペース区切りの整数のリストとして nums が与えられます。

出力形式:
最長増加部分列の長さを整数で出力してください。

制約:

nums の要素数は n で、1 <= n <= 1000 です。
nums の各要素の値は -10^9 <= nums[i] <= 10^9 です。
入力例1:

10 9 2 5 3 7 101 18
出力例1:

4
入力例2:

0 1 0 3 2 3
出力例2:

4
入力例3:

7 7 7 7 7 7 7
出力例3:

1
```


